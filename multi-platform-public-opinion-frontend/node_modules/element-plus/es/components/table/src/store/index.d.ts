import type { Ref } from 'vue';
import type { TableColumnCtx } from '../table-column/defaults';
import type { Filter, Sort } from '../table/defaults';
interface WatcherPropsData<T> {
    data: Ref<T[]>;
    rowKey: Ref<string>;
}
declare function useStore<T>(): {
    mutations: {
        setData(states: {
            _currentRowKey: Ref<string>;
            currentRow: Ref<T>;
            expandRowKeys: Ref<string[]>;
            treeData: Ref<unknown>;
            indent: Ref<number>;
            lazy: Ref<boolean>;
            lazyTreeNodeMap: Ref<{}>;
            lazyColumnIdentifier: Ref<string>;
            childrenColumnName: Ref<string>;
            checkStrictly: Ref<boolean>;
            expandRows: Ref<T[]>;
            defaultExpandAll: Ref<boolean>;
            tableSize: Ref<any>;
            rowKey: Ref<string>;
            data: Ref<T[]>;
            _data: Ref<T[]>;
            isComplex: Ref<boolean>;
            _columns: Ref<TableColumnCtx<T>[]>;
            originColumns: Ref<TableColumnCtx<T>[]>;
            columns: Ref<TableColumnCtx<T>[]>;
            fixedColumns: Ref<TableColumnCtx<T>[]>;
            rightFixedColumns: Ref<TableColumnCtx<T>[]>;
            leafColumns: Ref<TableColumnCtx<T>[]>;
            fixedLeafColumns: Ref<TableColumnCtx<T>[]>;
            rightFixedLeafColumns: Ref<TableColumnCtx<T>[]>;
            updateOrderFns: (() => void)[];
            leafColumnsLength: Ref<number>;
            fixedLeafColumnsLength: Ref<number>;
            rightFixedLeafColumnsLength: Ref<number>;
            isAllSelected: Ref<boolean>;
            selection: Ref<T[]>;
            reserveSelection: Ref<boolean>;
            selectOnIndeterminate: Ref<boolean>;
            selectable: Ref<(row: T, index: number) => boolean>;
            filters: Ref<StoreFilter>;
            filteredData: Ref<null>;
            sortingColumn: Ref<null>;
            sortProp: Ref<null>;
            sortOrder: Ref<null>;
            hoverRow: Ref<null>;
        }, data: T[]): void;
        insertColumn(states: {
            _currentRowKey: Ref<string>;
            currentRow: Ref<T>;
            expandRowKeys: Ref<string[]>;
            treeData: Ref<unknown>;
            indent: Ref<number>;
            lazy: Ref<boolean>;
            lazyTreeNodeMap: Ref<{}>;
            lazyColumnIdentifier: Ref<string>;
            childrenColumnName: Ref<string>;
            checkStrictly: Ref<boolean>;
            expandRows: Ref<T[]>;
            defaultExpandAll: Ref<boolean>;
            tableSize: Ref<any>;
            rowKey: Ref<string>;
            data: Ref<T[]>;
            _data: Ref<T[]>;
            isComplex: Ref<boolean>;
            _columns: Ref<TableColumnCtx<T>[]>;
            originColumns: Ref<TableColumnCtx<T>[]>;
            columns: Ref<TableColumnCtx<T>[]>;
            fixedColumns: Ref<TableColumnCtx<T>[]>;
            rightFixedColumns: Ref<TableColumnCtx<T>[]>;
            leafColumns: Ref<TableColumnCtx<T>[]>;
            fixedLeafColumns: Ref<TableColumnCtx<T>[]>;
            rightFixedLeafColumns: Ref<TableColumnCtx<T>[]>;
            updateOrderFns: (() => void)[];
            leafColumnsLength: Ref<number>;
            fixedLeafColumnsLength: Ref<number>;
            rightFixedLeafColumnsLength: Ref<number>;
            isAllSelected: Ref<boolean>;
            selection: Ref<T[]>;
            reserveSelection: Ref<boolean>;
            selectOnIndeterminate: Ref<boolean>;
            selectable: Ref<(row: T, index: number) => boolean>;
            filters: Ref<StoreFilter>;
            filteredData: Ref<null>;
            sortingColumn: Ref<null>;
            sortProp: Ref<null>;
            sortOrder: Ref<null>;
            hoverRow: Ref<null>;
        }, column: TableColumnCtx<T>, parent: TableColumnCtx<T>, updateColumnOrder: () => void): void;
        updateColumnOrder(states: {
            _currentRowKey: Ref<string>;
            currentRow: Ref<T>;
            expandRowKeys: Ref<string[]>;
            treeData: Ref<unknown>;
            indent: Ref<number>;
            lazy: Ref<boolean>;
            lazyTreeNodeMap: Ref<{}>;
            lazyColumnIdentifier: Ref<string>;
            childrenColumnName: Ref<string>;
            checkStrictly: Ref<boolean>;
            expandRows: Ref<T[]>;
            defaultExpandAll: Ref<boolean>;
            tableSize: Ref<any>;
            rowKey: Ref<string>;
            data: Ref<T[]>;
            _data: Ref<T[]>;
            isComplex: Ref<boolean>;
            _columns: Ref<TableColumnCtx<T>[]>;
            originColumns: Ref<TableColumnCtx<T>[]>;
            columns: Ref<TableColumnCtx<T>[]>;
            fixedColumns: Ref<TableColumnCtx<T>[]>;
            rightFixedColumns: Ref<TableColumnCtx<T>[]>;
            leafColumns: Ref<TableColumnCtx<T>[]>;
            fixedLeafColumns: Ref<TableColumnCtx<T>[]>;
            rightFixedLeafColumns: Ref<TableColumnCtx<T>[]>;
            updateOrderFns: (() => void)[];
            leafColumnsLength: Ref<number>;
            fixedLeafColumnsLength: Ref<number>;
            rightFixedLeafColumnsLength: Ref<number>;
            isAllSelected: Ref<boolean>;
            selection: Ref<T[]>;
            reserveSelection: Ref<boolean>;
            selectOnIndeterminate: Ref<boolean>;
            selectable: Ref<(row: T, index: number) => boolean>;
            filters: Ref<StoreFilter>;
            filteredData: Ref<null>;
            sortingColumn: Ref<null>;
            sortProp: Ref<null>;
            sortOrder: Ref<null>;
            hoverRow: Ref<null>;
        }, column: TableColumnCtx<T>): void;
        removeColumn(states: {
            _currentRowKey: Ref<string>;
            currentRow: Ref<T>;
            expandRowKeys: Ref<string[]>;
            treeData: Ref<unknown>;
            indent: Ref<number>;
            lazy: Ref<boolean>;
            lazyTreeNodeMap: Ref<{}>;
            lazyColumnIdentifier: Ref<string>;
            childrenColumnName: Ref<string>;
            checkStrictly: Ref<boolean>;
            expandRows: Ref<T[]>;
            defaultExpandAll: Ref<boolean>;
            tableSize: Ref<any>;
            rowKey: Ref<string>;
            data: Ref<T[]>;
            _data: Ref<T[]>;
            isComplex: Ref<boolean>;
            _columns: Ref<TableColumnCtx<T>[]>;
            originColumns: Ref<TableColumnCtx<T>[]>;
            columns: Ref<TableColumnCtx<T>[]>;
            fixedColumns: Ref<TableColumnCtx<T>[]>;
            rightFixedColumns: Ref<TableColumnCtx<T>[]>;
            leafColumns: Ref<TableColumnCtx<T>[]>;
            fixedLeafColumns: Ref<TableColumnCtx<T>[]>;
            rightFixedLeafColumns: Ref<TableColumnCtx<T>[]>;
            updateOrderFns: (() => void)[];
            leafColumnsLength: Ref<number>;
            fixedLeafColumnsLength: Ref<number>;
            rightFixedLeafColumnsLength: Ref<number>;
            isAllSelected: Ref<boolean>;
            selection: Ref<T[]>;
            reserveSelection: Ref<boolean>;
            selectOnIndeterminate: Ref<boolean>;
            selectable: Ref<(row: T, index: number) => boolean>;
            filters: Ref<StoreFilter>;
            filteredData: Ref<null>;
            sortingColumn: Ref<null>;
            sortProp: Ref<null>;
            sortOrder: Ref<null>;
            hoverRow: Ref<null>;
        }, column: TableColumnCtx<T>, parent: TableColumnCtx<T>, updateColumnOrder: () => void): void;
        sort(states: {
            _currentRowKey: Ref<string>;
            currentRow: Ref<T>;
            expandRowKeys: Ref<string[]>;
            treeData: Ref<unknown>;
            indent: Ref<number>;
            lazy: Ref<boolean>;
            lazyTreeNodeMap: Ref<{}>;
            lazyColumnIdentifier: Ref<string>;
            childrenColumnName: Ref<string>;
            checkStrictly: Ref<boolean>;
            expandRows: Ref<T[]>;
            defaultExpandAll: Ref<boolean>;
            tableSize: Ref<any>;
            rowKey: Ref<string>;
            data: Ref<T[]>;
            _data: Ref<T[]>;
            isComplex: Ref<boolean>;
            _columns: Ref<TableColumnCtx<T>[]>;
            originColumns: Ref<TableColumnCtx<T>[]>;
            columns: Ref<TableColumnCtx<T>[]>;
            fixedColumns: Ref<TableColumnCtx<T>[]>;
            rightFixedColumns: Ref<TableColumnCtx<T>[]>;
            leafColumns: Ref<TableColumnCtx<T>[]>;
            fixedLeafColumns: Ref<TableColumnCtx<T>[]>;
            rightFixedLeafColumns: Ref<TableColumnCtx<T>[]>;
            updateOrderFns: (() => void)[];
            leafColumnsLength: Ref<number>;
            fixedLeafColumnsLength: Ref<number>;
            rightFixedLeafColumnsLength: Ref<number>;
            isAllSelected: Ref<boolean>;
            selection: Ref<T[]>;
            reserveSelection: Ref<boolean>;
            selectOnIndeterminate: Ref<boolean>;
            selectable: Ref<(row: T, index: number) => boolean>;
            filters: Ref<StoreFilter>;
            filteredData: Ref<null>;
            sortingColumn: Ref<null>;
            sortProp: Ref<null>;
            sortOrder: Ref<null>;
            hoverRow: Ref<null>;
        }, options: Sort): void;
        changeSortCondition(states: {
            _currentRowKey: Ref<string>;
            currentRow: Ref<T>;
            expandRowKeys: Ref<string[]>;
            treeData: Ref<unknown>;
            indent: Ref<number>;
            lazy: Ref<boolean>;
            lazyTreeNodeMap: Ref<{}>;
            lazyColumnIdentifier: Ref<string>;
            childrenColumnName: Ref<string>;
            checkStrictly: Ref<boolean>;
            expandRows: Ref<T[]>;
            defaultExpandAll: Ref<boolean>;
            tableSize: Ref<any>;
            rowKey: Ref<string>;
            data: Ref<T[]>;
            _data: Ref<T[]>;
            isComplex: Ref<boolean>;
            _columns: Ref<TableColumnCtx<T>[]>;
            originColumns: Ref<TableColumnCtx<T>[]>;
            columns: Ref<TableColumnCtx<T>[]>;
            fixedColumns: Ref<TableColumnCtx<T>[]>;
            rightFixedColumns: Ref<TableColumnCtx<T>[]>;
            leafColumns: Ref<TableColumnCtx<T>[]>;
            fixedLeafColumns: Ref<TableColumnCtx<T>[]>;
            rightFixedLeafColumns: Ref<TableColumnCtx<T>[]>;
            updateOrderFns: (() => void)[];
            leafColumnsLength: Ref<number>;
            fixedLeafColumnsLength: Ref<number>;
            rightFixedLeafColumnsLength: Ref<number>;
            isAllSelected: Ref<boolean>;
            selection: Ref<T[]>;
            reserveSelection: Ref<boolean>;
            selectOnIndeterminate: Ref<boolean>;
            selectable: Ref<(row: T, index: number) => boolean>;
            filters: Ref<StoreFilter>;
            filteredData: Ref<null>;
            sortingColumn: Ref<null>;
            sortProp: Ref<null>;
            sortOrder: Ref<null>;
            hoverRow: Ref<null>;
        }, options: Sort): void;
        filterChange(_states: {
            _currentRowKey: Ref<string>;
            currentRow: Ref<T>;
            expandRowKeys: Ref<string[]>;
            treeData: Ref<unknown>;
            indent: Ref<number>;
            lazy: Ref<boolean>;
            lazyTreeNodeMap: Ref<{}>;
            lazyColumnIdentifier: Ref<string>;
            childrenColumnName: Ref<string>;
            checkStrictly: Ref<boolean>;
            expandRows: Ref<T[]>;
            defaultExpandAll: Ref<boolean>;
            tableSize: Ref<any>;
            rowKey: Ref<string>;
            data: Ref<T[]>;
            _data: Ref<T[]>;
            isComplex: Ref<boolean>;
            _columns: Ref<TableColumnCtx<T>[]>;
            originColumns: Ref<TableColumnCtx<T>[]>;
            columns: Ref<TableColumnCtx<T>[]>;
            fixedColumns: Ref<TableColumnCtx<T>[]>;
            rightFixedColumns: Ref<TableColumnCtx<T>[]>;
            leafColumns: Ref<TableColumnCtx<T>[]>;
            fixedLeafColumns: Ref<TableColumnCtx<T>[]>;
            rightFixedLeafColumns: Ref<TableColumnCtx<T>[]>;
            updateOrderFns: (() => void)[];
            leafColumnsLength: Ref<number>;
            fixedLeafColumnsLength: Ref<number>;
            rightFixedLeafColumnsLength: Ref<number>;
            isAllSelected: Ref<boolean>;
            selection: Ref<T[]>;
            reserveSelection: Ref<boolean>;
            selectOnIndeterminate: Ref<boolean>;
            selectable: Ref<(row: T, index: number) => boolean>;
            filters: Ref<StoreFilter>;
            filteredData: Ref<null>;
            sortingColumn: Ref<null>;
            sortProp: Ref<null>;
            sortOrder: Ref<null>;
            hoverRow: Ref<null>;
        }, options: Filter<T>): void;
        toggleAllSelection(): void;
        rowSelectedChanged(_states: any, row: T): void;
        setHoverRow(states: {
            _currentRowKey: Ref<string>;
            currentRow: Ref<T>;
            expandRowKeys: Ref<string[]>;
            treeData: Ref<unknown>;
            indent: Ref<number>;
            lazy: Ref<boolean>;
            lazyTreeNodeMap: Ref<{}>;
            lazyColumnIdentifier: Ref<string>;
            childrenColumnName: Ref<string>;
            checkStrictly: Ref<boolean>;
            expandRows: Ref<T[]>;
            defaultExpandAll: Ref<boolean>;
            tableSize: Ref<any>;
            rowKey: Ref<string>;
            data: Ref<T[]>;
            _data: Ref<T[]>;
            isComplex: Ref<boolean>;
            _columns: Ref<TableColumnCtx<T>[]>;
            originColumns: Ref<TableColumnCtx<T>[]>;
            columns: Ref<TableColumnCtx<T>[]>;
            fixedColumns: Ref<TableColumnCtx<T>[]>;
            rightFixedColumns: Ref<TableColumnCtx<T>[]>;
            leafColumns: Ref<TableColumnCtx<T>[]>;
            fixedLeafColumns: Ref<TableColumnCtx<T>[]>;
            rightFixedLeafColumns: Ref<TableColumnCtx<T>[]>;
            updateOrderFns: (() => void)[];
            leafColumnsLength: Ref<number>;
            fixedLeafColumnsLength: Ref<number>;
            rightFixedLeafColumnsLength: Ref<number>;
            isAllSelected: Ref<boolean>;
            selection: Ref<T[]>;
            reserveSelection: Ref<boolean>;
            selectOnIndeterminate: Ref<boolean>;
            selectable: Ref<(row: T, index: number) => boolean>;
            filters: Ref<StoreFilter>;
            filteredData: Ref<null>;
            sortingColumn: Ref<null>;
            sortProp: Ref<null>;
            sortOrder: Ref<null>;
            hoverRow: Ref<null>;
        }, row: T): void;
        setCurrentRow(_states: any, row: T): void;
    };
    commit: (name: "sort" | "setData" | "insertColumn" | "updateColumnOrder" | "removeColumn" | "changeSortCondition" | "filterChange" | "toggleAllSelection" | "rowSelectedChanged" | "setHoverRow" | "setCurrentRow", ...args: any[]) => void;
    updateTableScrollY: () => void;
    assertRowKey: () => void;
    updateColumns: () => void;
    scheduleLayout: (needUpdateColumns?: boolean, immediate?: boolean) => void;
    isSelected: (row: import("../table/defaults").DefaultRow) => boolean;
    clearSelection: () => void;
    cleanSelection: () => void;
    getSelectionRows: () => T[];
    toggleRowSelection: (row: T, selected?: boolean, emitChange?: boolean, ignoreSelectable?: boolean) => void;
    _toggleAllSelection: () => void;
    toggleAllSelection: null;
    updateSelectionByRowKey: () => void;
    updateAllSelected: () => void;
    updateFilters: (columns: any, values: any) => {};
    updateCurrentRow: (_currentRow: T) => void;
    updateSort: (column: any, prop: any, order: any) => void;
    execFilter: () => void;
    execSort: () => void;
    execQuery: (ignore?: undefined) => void;
    clearFilter: (columnKeys: any) => void;
    clearSort: () => void;
    toggleRowExpansion: (row: T, expanded?: boolean) => void;
    setExpandRowKeysAdapter: (val: string[]) => void;
    setCurrentRowKey: (key: string) => void;
    toggleRowExpansionAdapter: (row: T, expanded?: boolean) => void;
    isRowExpanded: (row: T) => boolean;
    updateExpandRows: () => void;
    updateCurrentRowData: () => void;
    loadOrToggle: (row: any) => void;
    updateTreeData: (ifChangeExpandRowKeys?: boolean) => void;
    updateKeyChildren: (key: string, data: T[]) => void;
    states: {
        _currentRowKey: Ref<string>;
        currentRow: Ref<T>;
        expandRowKeys: Ref<string[]>;
        treeData: Ref<unknown>;
        indent: Ref<number>;
        lazy: Ref<boolean>;
        lazyTreeNodeMap: Ref<{}>;
        lazyColumnIdentifier: Ref<string>;
        childrenColumnName: Ref<string>;
        checkStrictly: Ref<boolean>;
        expandRows: Ref<T[]>;
        defaultExpandAll: Ref<boolean>;
        tableSize: Ref<any>;
        rowKey: Ref<string>;
        data: Ref<T[]>;
        _data: Ref<T[]>;
        isComplex: Ref<boolean>;
        _columns: Ref<TableColumnCtx<T>[]>;
        originColumns: Ref<TableColumnCtx<T>[]>;
        columns: Ref<TableColumnCtx<T>[]>;
        fixedColumns: Ref<TableColumnCtx<T>[]>;
        rightFixedColumns: Ref<TableColumnCtx<T>[]>;
        leafColumns: Ref<TableColumnCtx<T>[]>;
        fixedLeafColumns: Ref<TableColumnCtx<T>[]>;
        rightFixedLeafColumns: Ref<TableColumnCtx<T>[]>;
        updateOrderFns: (() => void)[];
        leafColumnsLength: Ref<number>;
        fixedLeafColumnsLength: Ref<number>;
        rightFixedLeafColumnsLength: Ref<number>;
        isAllSelected: Ref<boolean>;
        selection: Ref<T[]>;
        reserveSelection: Ref<boolean>;
        selectOnIndeterminate: Ref<boolean>;
        selectable: Ref<(row: T, index: number) => boolean>;
        filters: Ref<StoreFilter>;
        filteredData: Ref<null>;
        sortingColumn: Ref<null>;
        sortProp: Ref<null>;
        sortOrder: Ref<null>;
        hoverRow: Ref<null>;
    };
    ns: {
        namespace: import("vue").ComputedRef<string>;
        b: (blockSuffix?: string) => string;
        e: (element?: string) => string;
        m: (modifier?: string) => string;
        be: (blockSuffix?: string, element?: string) => string;
        em: (element?: string, modifier?: string) => string;
        bm: (blockSuffix?: string, modifier?: string) => string;
        bem: (blockSuffix?: string, element?: string, modifier?: string) => string;
        is: {
            (name: string, state: boolean | undefined): string;
            (name: string): string;
        };
        cssVar: (object: Record<string, string>) => Record<string, string>;
        cssVarName: (name: string) => string;
        cssVarBlock: (object: Record<string, string>) => Record<string, string>;
        cssVarBlockName: (name: string) => string;
    };
};
export default useStore;
declare class HelperStore<T> {
    Return: {
        mutations: {
            setData(states: {
                _currentRowKey: Ref<string>;
                currentRow: Ref<T>;
                expandRowKeys: Ref<string[]>;
                treeData: Ref<unknown>;
                indent: Ref<number>;
                lazy: Ref<boolean>;
                lazyTreeNodeMap: Ref<{}>;
                lazyColumnIdentifier: Ref<string>;
                childrenColumnName: Ref<string>;
                checkStrictly: Ref<boolean>;
                expandRows: Ref<T[]>;
                defaultExpandAll: Ref<boolean>;
                tableSize: Ref<any>;
                rowKey: Ref<string>;
                data: Ref<T[]>;
                _data: Ref<T[]>;
                isComplex: Ref<boolean>;
                _columns: Ref<TableColumnCtx<T>[]>;
                originColumns: Ref<TableColumnCtx<T>[]>;
                columns: Ref<TableColumnCtx<T>[]>;
                fixedColumns: Ref<TableColumnCtx<T>[]>;
                rightFixedColumns: Ref<TableColumnCtx<T>[]>;
                leafColumns: Ref<TableColumnCtx<T>[]>;
                fixedLeafColumns: Ref<TableColumnCtx<T>[]>;
                rightFixedLeafColumns: Ref<TableColumnCtx<T>[]>;
                updateOrderFns: (() => void)[];
                leafColumnsLength: Ref<number>;
                fixedLeafColumnsLength: Ref<number>;
                rightFixedLeafColumnsLength: Ref<number>;
                isAllSelected: Ref<boolean>;
                selection: Ref<T[]>;
                reserveSelection: Ref<boolean>;
                selectOnIndeterminate: Ref<boolean>;
                selectable: Ref<(row: T, index: number) => boolean>;
                filters: Ref<StoreFilter>;
                filteredData: Ref<null>;
                sortingColumn: Ref<null>;
                sortProp: Ref<null>;
                sortOrder: Ref<null>;
                hoverRow: Ref<null>;
            }, data: T[]): void;
            insertColumn(states: {
                _currentRowKey: Ref<string>;
                currentRow: Ref<T>;
                expandRowKeys: Ref<string[]>;
                treeData: Ref<unknown>;
                indent: Ref<number>;
                lazy: Ref<boolean>;
                lazyTreeNodeMap: Ref<{}>;
                lazyColumnIdentifier: Ref<string>;
                childrenColumnName: Ref<string>;
                checkStrictly: Ref<boolean>;
                expandRows: Ref<T[]>;
                defaultExpandAll: Ref<boolean>;
                tableSize: Ref<any>;
                rowKey: Ref<string>;
                data: Ref<T[]>;
                _data: Ref<T[]>;
                isComplex: Ref<boolean>;
                _columns: Ref<TableColumnCtx<T>[]>;
                originColumns: Ref<TableColumnCtx<T>[]>;
                columns: Ref<TableColumnCtx<T>[]>;
                fixedColumns: Ref<TableColumnCtx<T>[]>;
                rightFixedColumns: Ref<TableColumnCtx<T>[]>;
                leafColumns: Ref<TableColumnCtx<T>[]>;
                fixedLeafColumns: Ref<TableColumnCtx<T>[]>;
                rightFixedLeafColumns: Ref<TableColumnCtx<T>[]>;
                updateOrderFns: (() => void)[];
                leafColumnsLength: Ref<number>;
                fixedLeafColumnsLength: Ref<number>;
                rightFixedLeafColumnsLength: Ref<number>;
                isAllSelected: Ref<boolean>;
                selection: Ref<T[]>;
                reserveSelection: Ref<boolean>;
                selectOnIndeterminate: Ref<boolean>;
                selectable: Ref<(row: T, index: number) => boolean>;
                filters: Ref<StoreFilter>;
                filteredData: Ref<null>;
                sortingColumn: Ref<null>;
                sortProp: Ref<null>;
                sortOrder: Ref<null>;
                hoverRow: Ref<null>;
            }, column: TableColumnCtx<T>, parent: TableColumnCtx<T>, updateColumnOrder: () => void): void;
            updateColumnOrder(states: {
                _currentRowKey: Ref<string>;
                currentRow: Ref<T>;
                expandRowKeys: Ref<string[]>;
                treeData: Ref<unknown>;
                indent: Ref<number>;
                lazy: Ref<boolean>;
                lazyTreeNodeMap: Ref<{}>;
                lazyColumnIdentifier: Ref<string>;
                childrenColumnName: Ref<string>;
                checkStrictly: Ref<boolean>;
                expandRows: Ref<T[]>;
                defaultExpandAll: Ref<boolean>;
                tableSize: Ref<any>;
                rowKey: Ref<string>;
                data: Ref<T[]>;
                _data: Ref<T[]>;
                isComplex: Ref<boolean>;
                _columns: Ref<TableColumnCtx<T>[]>;
                originColumns: Ref<TableColumnCtx<T>[]>;
                columns: Ref<TableColumnCtx<T>[]>;
                fixedColumns: Ref<TableColumnCtx<T>[]>;
                rightFixedColumns: Ref<TableColumnCtx<T>[]>;
                leafColumns: Ref<TableColumnCtx<T>[]>;
                fixedLeafColumns: Ref<TableColumnCtx<T>[]>;
                rightFixedLeafColumns: Ref<TableColumnCtx<T>[]>;
                updateOrderFns: (() => void)[];
                leafColumnsLength: Ref<number>;
                fixedLeafColumnsLength: Ref<number>;
                rightFixedLeafColumnsLength: Ref<number>;
                isAllSelected: Ref<boolean>;
                selection: Ref<T[]>;
                reserveSelection: Ref<boolean>;
                selectOnIndeterminate: Ref<boolean>;
                selectable: Ref<(row: T, index: number) => boolean>;
                filters: Ref<StoreFilter>;
                filteredData: Ref<null>;
                sortingColumn: Ref<null>;
                sortProp: Ref<null>;
                sortOrder: Ref<null>;
                hoverRow: Ref<null>;
            }, column: TableColumnCtx<T>): void;
            removeColumn(states: {
                _currentRowKey: Ref<string>;
                currentRow: Ref<T>;
                expandRowKeys: Ref<string[]>;
                treeData: Ref<unknown>;
                indent: Ref<number>;
                lazy: Ref<boolean>;
                lazyTreeNodeMap: Ref<{}>;
                lazyColumnIdentifier: Ref<string>;
                childrenColumnName: Ref<string>;
                checkStrictly: Ref<boolean>;
                expandRows: Ref<T[]>;
                defaultExpandAll: Ref<boolean>;
                tableSize: Ref<any>;
                rowKey: Ref<string>;
                data: Ref<T[]>;
                _data: Ref<T[]>;
                isComplex: Ref<boolean>;
                _columns: Ref<TableColumnCtx<T>[]>;
                originColumns: Ref<TableColumnCtx<T>[]>;
                columns: Ref<TableColumnCtx<T>[]>;
                fixedColumns: Ref<TableColumnCtx<T>[]>;
                rightFixedColumns: Ref<TableColumnCtx<T>[]>;
                leafColumns: Ref<TableColumnCtx<T>[]>;
                fixedLeafColumns: Ref<TableColumnCtx<T>[]>;
                rightFixedLeafColumns: Ref<TableColumnCtx<T>[]>;
                updateOrderFns: (() => void)[];
                leafColumnsLength: Ref<number>;
                fixedLeafColumnsLength: Ref<number>;
                rightFixedLeafColumnsLength: Ref<number>;
                isAllSelected: Ref<boolean>;
                selection: Ref<T[]>;
                reserveSelection: Ref<boolean>;
                selectOnIndeterminate: Ref<boolean>;
                selectable: Ref<(row: T, index: number) => boolean>;
                filters: Ref<StoreFilter>;
                filteredData: Ref<null>;
                sortingColumn: Ref<null>;
                sortProp: Ref<null>;
                sortOrder: Ref<null>;
                hoverRow: Ref<null>;
            }, column: TableColumnCtx<T>, parent: TableColumnCtx<T>, updateColumnOrder: () => void): void;
            sort(states: {
                _currentRowKey: Ref<string>;
                currentRow: Ref<T>;
                expandRowKeys: Ref<string[]>;
                treeData: Ref<unknown>;
                indent: Ref<number>;
                lazy: Ref<boolean>;
                lazyTreeNodeMap: Ref<{}>;
                lazyColumnIdentifier: Ref<string>;
                childrenColumnName: Ref<string>;
                checkStrictly: Ref<boolean>;
                expandRows: Ref<T[]>;
                defaultExpandAll: Ref<boolean>;
                tableSize: Ref<any>;
                rowKey: Ref<string>;
                data: Ref<T[]>;
                _data: Ref<T[]>;
                isComplex: Ref<boolean>;
                _columns: Ref<TableColumnCtx<T>[]>;
                originColumns: Ref<TableColumnCtx<T>[]>;
                columns: Ref<TableColumnCtx<T>[]>;
                fixedColumns: Ref<TableColumnCtx<T>[]>;
                rightFixedColumns: Ref<TableColumnCtx<T>[]>;
                leafColumns: Ref<TableColumnCtx<T>[]>;
                fixedLeafColumns: Ref<TableColumnCtx<T>[]>;
                rightFixedLeafColumns: Ref<TableColumnCtx<T>[]>;
                updateOrderFns: (() => void)[];
                leafColumnsLength: Ref<number>;
                fixedLeafColumnsLength: Ref<number>;
                rightFixedLeafColumnsLength: Ref<number>;
                isAllSelected: Ref<boolean>;
                selection: Ref<T[]>;
                reserveSelection: Ref<boolean>;
                selectOnIndeterminate: Ref<boolean>;
                selectable: Ref<(row: T, index: number) => boolean>;
                filters: Ref<StoreFilter>;
                filteredData: Ref<null>;
                sortingColumn: Ref<null>;
                sortProp: Ref<null>;
                sortOrder: Ref<null>;
                hoverRow: Ref<null>;
            }, options: Sort): void;
            changeSortCondition(states: {
                _currentRowKey: Ref<string>;
                currentRow: Ref<T>;
                expandRowKeys: Ref<string[]>;
                treeData: Ref<unknown>;
                indent: Ref<number>;
                lazy: Ref<boolean>;
                lazyTreeNodeMap: Ref<{}>;
                lazyColumnIdentifier: Ref<string>;
                childrenColumnName: Ref<string>;
                checkStrictly: Ref<boolean>;
                expandRows: Ref<T[]>;
                defaultExpandAll: Ref<boolean>;
                tableSize: Ref<any>;
                rowKey: Ref<string>;
                data: Ref<T[]>;
                _data: Ref<T[]>;
                isComplex: Ref<boolean>;
                _columns: Ref<TableColumnCtx<T>[]>;
                originColumns: Ref<TableColumnCtx<T>[]>;
                columns: Ref<TableColumnCtx<T>[]>;
                fixedColumns: Ref<TableColumnCtx<T>[]>;
                rightFixedColumns: Ref<TableColumnCtx<T>[]>;
                leafColumns: Ref<TableColumnCtx<T>[]>;
                fixedLeafColumns: Ref<TableColumnCtx<T>[]>;
                rightFixedLeafColumns: Ref<TableColumnCtx<T>[]>;
                updateOrderFns: (() => void)[];
                leafColumnsLength: Ref<number>;
                fixedLeafColumnsLength: Ref<number>;
                rightFixedLeafColumnsLength: Ref<number>;
                isAllSelected: Ref<boolean>;
                selection: Ref<T[]>;
                reserveSelection: Ref<boolean>;
                selectOnIndeterminate: Ref<boolean>;
                selectable: Ref<(row: T, index: number) => boolean>;
                filters: Ref<StoreFilter>;
                filteredData: Ref<null>;
                sortingColumn: Ref<null>;
                sortProp: Ref<null>;
                sortOrder: Ref<null>;
                hoverRow: Ref<null>;
            }, options: Sort): void;
            filterChange(_states: {
                _currentRowKey: Ref<string>;
                currentRow: Ref<T>;
                expandRowKeys: Ref<string[]>;
                treeData: Ref<unknown>;
                indent: Ref<number>;
                lazy: Ref<boolean>;
                lazyTreeNodeMap: Ref<{}>;
                lazyColumnIdentifier: Ref<string>;
                childrenColumnName: Ref<string>;
                checkStrictly: Ref<boolean>;
                expandRows: Ref<T[]>;
                defaultExpandAll: Ref<boolean>;
                tableSize: Ref<any>;
                rowKey: Ref<string>;
                data: Ref<T[]>;
                _data: Ref<T[]>;
                isComplex: Ref<boolean>;
                _columns: Ref<TableColumnCtx<T>[]>;
                originColumns: Ref<TableColumnCtx<T>[]>;
                columns: Ref<TableColumnCtx<T>[]>;
                fixedColumns: Ref<TableColumnCtx<T>[]>;
                rightFixedColumns: Ref<TableColumnCtx<T>[]>;
                leafColumns: Ref<TableColumnCtx<T>[]>;
                fixedLeafColumns: Ref<TableColumnCtx<T>[]>;
                rightFixedLeafColumns: Ref<TableColumnCtx<T>[]>;
                updateOrderFns: (() => void)[];
                leafColumnsLength: Ref<number>;
                fixedLeafColumnsLength: Ref<number>;
                rightFixedLeafColumnsLength: Ref<number>;
                isAllSelected: Ref<boolean>;
                selection: Ref<T[]>;
                reserveSelection: Ref<boolean>;
                selectOnIndeterminate: Ref<boolean>;
                selectable: Ref<(row: T, index: number) => boolean>;
                filters: Ref<StoreFilter>;
                filteredData: Ref<null>;
                sortingColumn: Ref<null>;
                sortProp: Ref<null>;
                sortOrder: Ref<null>;
                hoverRow: Ref<null>;
            }, options: Filter<T>): void;
            toggleAllSelection(): void;
            rowSelectedChanged(_states: any, row: T): void;
            setHoverRow(states: {
                _currentRowKey: Ref<string>;
                currentRow: Ref<T>;
                expandRowKeys: Ref<string[]>;
                treeData: Ref<unknown>;
                indent: Ref<number>;
                lazy: Ref<boolean>;
                lazyTreeNodeMap: Ref<{}>;
                lazyColumnIdentifier: Ref<string>;
                childrenColumnName: Ref<string>;
                checkStrictly: Ref<boolean>;
                expandRows: Ref<T[]>;
                defaultExpandAll: Ref<boolean>;
                tableSize: Ref<any>;
                rowKey: Ref<string>;
                data: Ref<T[]>;
                _data: Ref<T[]>;
                isComplex: Ref<boolean>;
                _columns: Ref<TableColumnCtx<T>[]>;
                originColumns: Ref<TableColumnCtx<T>[]>;
                columns: Ref<TableColumnCtx<T>[]>;
                fixedColumns: Ref<TableColumnCtx<T>[]>;
                rightFixedColumns: Ref<TableColumnCtx<T>[]>;
                leafColumns: Ref<TableColumnCtx<T>[]>;
                fixedLeafColumns: Ref<TableColumnCtx<T>[]>;
                rightFixedLeafColumns: Ref<TableColumnCtx<T>[]>;
                updateOrderFns: (() => void)[];
                leafColumnsLength: Ref<number>;
                fixedLeafColumnsLength: Ref<number>;
                rightFixedLeafColumnsLength: Ref<number>;
                isAllSelected: Ref<boolean>;
                selection: Ref<T[]>;
                reserveSelection: Ref<boolean>;
                selectOnIndeterminate: Ref<boolean>;
                selectable: Ref<(row: T, index: number) => boolean>;
                filters: Ref<StoreFilter>;
                filteredData: Ref<null>;
                sortingColumn: Ref<null>;
                sortProp: Ref<null>;
                sortOrder: Ref<null>;
                hoverRow: Ref<null>;
            }, row: T): void;
            setCurrentRow(_states: any, row: T): void;
        };
        commit: (name: "sort" | "setData" | "insertColumn" | "updateColumnOrder" | "removeColumn" | "changeSortCondition" | "filterChange" | "toggleAllSelection" | "rowSelectedChanged" | "setHoverRow" | "setCurrentRow", ...args: any[]) => void;
        updateTableScrollY: () => void;
        assertRowKey: () => void;
        updateColumns: () => void;
        scheduleLayout: (needUpdateColumns?: boolean, immediate?: boolean) => void;
        isSelected: (row: import("../table/defaults").DefaultRow) => boolean;
        clearSelection: () => void;
        cleanSelection: () => void;
        getSelectionRows: () => T[];
        toggleRowSelection: (row: T, selected?: boolean, emitChange?: boolean, ignoreSelectable?: boolean) => void;
        _toggleAllSelection: () => void;
        toggleAllSelection: null;
        updateSelectionByRowKey: () => void;
        updateAllSelected: () => void;
        updateFilters: (columns: any, values: any) => {};
        updateCurrentRow: (_currentRow: T) => void;
        updateSort: (column: any, prop: any, order: any) => void;
        execFilter: () => void;
        execSort: () => void;
        execQuery: (ignore?: undefined) => void;
        clearFilter: (columnKeys: any) => void;
        clearSort: () => void;
        toggleRowExpansion: (row: T, expanded?: boolean) => void;
        setExpandRowKeysAdapter: (val: string[]) => void;
        setCurrentRowKey: (key: string) => void;
        toggleRowExpansionAdapter: (row: T, expanded?: boolean) => void;
        isRowExpanded: (row: T) => boolean;
        updateExpandRows: () => void;
        updateCurrentRowData: () => void;
        loadOrToggle: (row: any) => void;
        updateTreeData: (ifChangeExpandRowKeys?: boolean) => void;
        updateKeyChildren: (key: string, data: T[]) => void;
        states: {
            _currentRowKey: Ref<string>;
            currentRow: Ref<T>;
            expandRowKeys: Ref<string[]>;
            treeData: Ref<unknown>;
            indent: Ref<number>;
            lazy: Ref<boolean>;
            lazyTreeNodeMap: Ref<{}>;
            lazyColumnIdentifier: Ref<string>;
            childrenColumnName: Ref<string>;
            checkStrictly: Ref<boolean>;
            expandRows: Ref<T[]>;
            defaultExpandAll: Ref<boolean>;
            tableSize: Ref<any>;
            rowKey: Ref<string>;
            data: Ref<T[]>;
            _data: Ref<T[]>;
            isComplex: Ref<boolean>;
            _columns: Ref<TableColumnCtx<T>[]>;
            originColumns: Ref<TableColumnCtx<T>[]>;
            columns: Ref<TableColumnCtx<T>[]>;
            fixedColumns: Ref<TableColumnCtx<T>[]>;
            rightFixedColumns: Ref<TableColumnCtx<T>[]>;
            leafColumns: Ref<TableColumnCtx<T>[]>;
            fixedLeafColumns: Ref<TableColumnCtx<T>[]>;
            rightFixedLeafColumns: Ref<TableColumnCtx<T>[]>;
            updateOrderFns: (() => void)[];
            leafColumnsLength: Ref<number>;
            fixedLeafColumnsLength: Ref<number>;
            rightFixedLeafColumnsLength: Ref<number>;
            isAllSelected: Ref<boolean>;
            selection: Ref<T[]>;
            reserveSelection: Ref<boolean>;
            selectOnIndeterminate: Ref<boolean>;
            selectable: Ref<(row: T, index: number) => boolean>;
            filters: Ref<StoreFilter>;
            filteredData: Ref<null>;
            sortingColumn: Ref<null>;
            sortProp: Ref<null>;
            sortOrder: Ref<null>;
            hoverRow: Ref<null>;
        };
        ns: {
            namespace: import("vue").ComputedRef<string>;
            b: (blockSuffix?: string) => string;
            e: (element?: string) => string;
            m: (modifier?: string) => string;
            be: (blockSuffix?: string, element?: string) => string;
            em: (element?: string, modifier?: string) => string;
            bm: (blockSuffix?: string, modifier?: string) => string;
            bem: (blockSuffix?: string, element?: string, modifier?: string) => string;
            is: {
                (name: string, state: boolean | undefined): string;
                (name: string): string;
            };
            cssVar: (object: Record<string, string>) => Record<string, string>;
            cssVarName: (name: string) => string;
            cssVarBlock: (object: Record<string, string>) => Record<string, string>;
            cssVarBlockName: (name: string) => string;
        };
    };
}
type StoreFilter = Record<string, string[]>;
type Store<T> = HelperStore<T>['Return'];
export type { WatcherPropsData, Store, StoreFilter };
